
int globalMinute = 0;
int lastMinute = -1;
int realWidth;
const float PI = 3.141592;


void drawSolidMinuteHand(int minute, int color, int screenW) {
	int cx, cy;
	int radius;
	float angle;
	float dx, dy;
	float adx, ady;
	int i;
	int x, y;
	int density;

	cx = screenW / 2;
	cy = (screenW / 2) - 5;
	radius = screenW / 5;

	// densidad según resolución
	if (screenW >= 300)
		density = 2;
	else
		density = 1;

	angle = (minute * 6 - 90) * PI / 180;

	dx = cos(angle);
	dy = sin(angle);

	// abs manual
	if (dx < 0) adx = -dx; else adx = dx;
	if (dy < 0) ady = -dy; else ady = dy;

	for (i = 0; i < radius * density; i++) {
		x = cx + dx * i / density;
		y = cy + dy * i / density;

		if (adx > ady) {
			draw.rect(color, x, y - 1, x + 1, y + 1, 0);
		} else {
			draw.rect(color, x - 1, y, x + 1, y + 1, 0);
		}
	}
}


void drawClockTest(int minute, int screen) {
	int cx, cy, screenW;
	
	screenW = screen;
	
	if (screenW > 300) {
		cx = screenW / 8;
		cy = (screenW / 8) - 10;
	}
	else
	{
		cx = screenW / 2;
		cy = (screenW / 2) - 5;
	}

	draw.begin();

	// reloj
	draw.frame(
		clrFG,
		cx - screenW/4, cy - screenW/4,
		cx + screenW/4, cy + screenW/4,
		screenW/4, 2
	);

	// borrar anterior
	if (lastMinute >= 0)
		drawSolidMinuteHand(lastMinute, clrBG, screen);

	// dibujar nueva
	drawSolidMinuteHand(minute, clrFG, screen);

	draw.pixel(clrFG, cx, cy);
	draw.end();

	lastMinute = minute;
}


handler testForm.onopen() {
	draw.attachForm(this);
}


handler testForm.ondraw() {
	draw.nbegin(); // gets native resolution
	realWidth = this.w;
	draw.end();
	
	draw.begin();
	draw.text(clrFG, 10, 140, realWidth);
	draw.end();
	
	drawClockTest(globalMinute, realWidth);
}


handler backTestButton.onselect() {
	mainForm.load();
}


handler plusButton.onselect() {
	globalMinute++;
	
	if (globalMinute == 60) globalMinute = 0;
	
	drawClockTest(globalMinute, realWidth);
}
